#!/usr/bin/env python3
import os
import sys

limbs = 8
sys.setrecursionlimit(10000)

print("Generating mul_vec512.S...")

def introduce_global_function(f, name):
    f.write('.global %s\n' % name)
    f.write('%s: \n' % name)

def comment(f, comment):
    f.write('/* %s */\n' % comment)

def maybeupdate(fn):
  if os.access(fn,os.F_OK):
    with open(fn) as f:
      x = f.read()
    with open(fn+'.tmp') as f:
      y = f.read()
    if x == y:
      os.unlink(fn+'.tmp')
      return
  os.rename(fn+'.tmp',fn)

def sub_stack_and_store_on_stack(f, regs, additional_offset):
    total_offset = len(regs)*8 + additional_offset 
    if total_offset % 16 != 0:
        total_offset = ((total_offset // 16) + 1) * 16
    f.write('\tsub sp, sp, #%d\n' % total_offset)
    offset = 0
    i = 0
    while i < len(regs):
        # Check if there's at least one more register after the current one
        if i + 1 < len(regs):
            # If yes, store the pair of registers
            f.write('\tstp %s, %s, [sp, #%d]\n' % (regs[i], regs[i+1], offset))
            i += 2
        else:
            # If no, store the single register
            f.write('\tstr %s, [sp, #%d]\n' % (regs[i],offset))
            i += 1
        offset += 16

def add_stack_and_restore_regs_from_stack(f, regs, additional_offset):
    total_offset = len(regs)*8 + additional_offset 
    if total_offset % 16 != 0:
        total_offset = ((total_offset // 16) + 1) * 16
    offset = 0
    i = 0
    while i < len(regs):
        # Check if there's at least one more register after the current one
        if i + 1 < len(regs):
            # If yes, store the pair of registers
            f.write('\tldp %s, %s, [sp, #%d]\n' % (regs[i], regs[i+1], offset))
            i += 2
        else:
            # If no, store the single register
            f.write('\tldr %s, [sp, #%d]\n' % (regs[i],offset))
            i += 1
        offset += 16
    f.write('\tadd sp, sp, #%d\n' % total_offset)


fn = "../mul_vec512.S"
with open(fn+'.tmp','w') as f:
    f.write('/* DO NOT EDIT! generated by autogen */\n\n')

    f.write('.text\n')
    f.write('.align 4\n\n')
    
    introduce_global_function(f, '_mul_vec')
    addr_a = 'X0'
    addr_b = 'X1'
    a = ['V0', 'V1', 'V2', 'V3']
    b = ['V4', 'V5', 'V6', 'V7']
    c = ['V9', 'V10', 'V11', 'V12']

    
    # Load A
    f.write('\tld1 {%s.2D, %s.2D, %s.2D, %s.2D}, [%s] // load a\n' % (a[0], a[1], a[2], a[3], addr_a))

    # Load B
    f.write('\tld1 {%s.2D, %s.2D, %s.2D, %s.2D}, [%s] // load b\n' % (b[0], b[1], b[2], b[3], addr_b))

    
    # Multiply A[0] with B[0]
    f.write('\tmul %s.2s, %s.2s, %s.2s // multiply a[0] with b\n' % (c[0], b[0], a[0]))
    
    # Store C
    f.write('\tst1 {%s.2D, %s.2D, %s.2D, %s.2D}, [%s] // store c\n' % (c[0], c[1], c[2], c[3], addr_a))

    f.write('\tret\n\n')
    maybeupdate(fn)