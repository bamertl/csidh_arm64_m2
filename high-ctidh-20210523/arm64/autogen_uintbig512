#!/usr/bin/env python3

import os
import math
import re
import sys
limbs = 8
sys.setrecursionlimit(10000)

globals = {
  'uint_big_p': 'uintbig_p',
  'uint_big_1': 'uintbig_1',
  'uintbig_bit': 'uintbig_bit',
  'uintbig_set': 'uintbig_set',
  'uintbig_add3': 'uintbig_add3',
  'uintbig_sub3': 'uintbig_sub3',
  'uintbig_mul3_64': 'uintbig_mul3_64',
  'uintbig_four_sqrt_p': 'uintbig_four_sqrt_p', 
  'uintbig_mul3_64_full': 'uintbig_mul3_64_full'}

def maybeupdate(fn):
  if os.access(fn,os.F_OK):
    with open(fn) as f:
      x = f.read()
    with open(fn+'.tmp') as f:
      y = f.read()
    if x == y:
      os.unlink(fn+'.tmp')
      return
  os.rename(fn+'.tmp',fn)

def comment(f, comment):
    f.write('/* %s */\n' % comment)

def init_data_var(f, name):
    f.write('.global %s\n' % name)
    f.write('%s: \n' % name)
    f.write('\t.quad 0\n')

def introduce_global_function(f, name):
    f.write('.global %s\n' % name)
    f.write('%s: \n' % name)


def sub_stack_and_store_on_stack(f, regs, additional_offset):
    total_offset = len(regs)*8 + additional_offset 
    if total_offset % 16 != 0:
        total_offset = ((total_offset // 16) + 1) * 16
    f.write('\tsub sp, sp, #%d\n' % total_offset)
    offset = 0
    i = 0
    while i < len(regs):
        # Check if there's at least one more register after the current one
        if i + 1 < len(regs):
            # If yes, store the pair of registers
            f.write('\tstp %s, %s, [sp, #%d]\n' % (regs[i], regs[i+1], offset))
            i += 2
        else:
            # If no, store the single register
            f.write('\tstr %s, [sp, #%d]\n' % (regs[i],offset))
            i += 1
        offset += 16

def add_stack_and_restore_regs_from_stack(f, regs, additional_offset):
    total_offset = len(regs)*8 + additional_offset 
    if total_offset % 16 != 0:
        total_offset = ((total_offset // 16) + 1) * 16
    offset = 0
    i = 0
    while i < len(regs):
        # Check if there's at least one more register after the current one
        if i + 1 < len(regs):
            # If yes, store the pair of registers
            f.write('\tldp %s, %s, [sp, #%d]\n' % (regs[i], regs[i+1], offset))
            i += 2
        else:
            # If no, store the single register
            f.write('\tldr %s, [sp, #%d]\n' % (regs[i],offset))
            i += 1
        offset += 16
    f.write('\tadd sp, sp, #%d\n' % total_offset)

print("Generating uintbig512_arm64.S ...")

fn = "../uintbig512_arm64.S"
with open(fn+'.tmp','w') as f:
  f.write('/* DO NOT EDIT! generated by autogen */\n\n')
  f.write('#include "uintbig_namespace.h" \n')
  f.write('.data\n\n')

  introduce_global_function(f, globals['uint_big_1'])
  f.write('\t.quad 1, 0, 0, 0\n')
  f.write('\t.quad 0, 0, 0, 0\n\n')
  introduce_global_function(f, globals['uint_big_p'])
  f.write('\t.quad 0x1b81b90533c6c87b, 0xc2721bf457aca835, 0x516730cc1f0b4f25, 0xa7aac6c567f35507\n')
  f.write('\t.quad 0x5afbfcc69322c9cd, 0xb42d083aedc88c42, 0xfc8ab0d15e3e4c4a, 0x65b48e8f740f89bf\n\n')

  introduce_global_function(f, globals['uintbig_four_sqrt_p'])
  f.write('\t.quad 0x17895e71e1a20b3f, 0x38d0cd95f8636a56, 0x142b9541e59682cd, 0x856f1399d91d6592\n')
  f.write('\t.quad 2, 0, 0, 0\n\n')

  f.write('.text\n')
  f.write('.align 4\n\n')

  ## _UINTBIG_SET ______________________________________________________________________________________________
  comment(f, "A[x0][0] = x1, rest 0")
  introduce_global_function(f, globals['uintbig_set'])
  f.write('\tstr x1, [x0]\n')
  f.write('\tmov x2, 0\n')
  f.write('\tstp x1, x2, [x0, #0]\n')
  
  for i in range(1, int(limbs/2)):
    offset = i*16
    f.write('\tstp x2, x2, [x0, #%d]\n' % offset)
  f.write('\tret\n\n')

  ## _UINTBIG_BIT ______________________________________________________________________________________________
  comment(f, "Operation: x0 = x0[x1] == 1")
  comment(f, "Checks if bit at position x1 is set")
  introduce_global_function(f, globals['uintbig_bit'])
  f.write('\tand x2, x1, #0x3F   // x2 = x0 % 64 using bitwise AND\n')
  f.write('\tlsr x1, x1, #6      // x1 = x1 / 64 by right-shifting\n')
  f.write('\tlsl x1, x1, #3      // 8 * (x1 / 64) \n')
  f.write('\tldr x3, [x0, x1]    // Load the limb at: x0 + 8 * (k / 64) \n')
  f.write('\tlsr x3, x3, x2  // Right shift by x0%64 to bring the bit of interest to the least significant position\n')
  f.write('\tand x0, x3, #1  // Check if the least significant bit is set\n')
  f.write('\tret\n\n')

  ## _UINTBIG_ADD3 ______________________________________________________________________________________________
  comment(f, "Operation: A[x0] = B[x1] + C[x2] and x0 = carry")
  introduce_global_function(f, globals['uintbig_add3'])
  CALLE_SAVE_REGS = ['x19', 'x20']
  B_REGS = ['x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9', 'x10']
  C_REGS = ['x11', 'x12', 'x13', 'x14', 'x15', 'x16', 'x17', 'x19']
  sub_stack_and_store_on_stack(f, CALLE_SAVE_REGS, 0)
  for i in range(int(limbs/2)):
    offset = i*16
    f.write('\tldp %s, %s, [x1, #%d]\n' % (B_REGS[i*2], B_REGS[i*2+1], offset))
    f.write('\tldp %s, %s, [x2, #%d]\n' % (C_REGS[i*2], C_REGS[i*2+1], offset))
  f.write('\tadds %s, %s, %s\n' % (B_REGS[0], B_REGS[0], C_REGS[0]))
  for i in range(1, limbs):
    f.write('\tadcs %s, %s, %s\n' % (B_REGS[i], B_REGS[i], C_REGS[i]))
  for i in range(int(limbs/2)):
    offset = i*16
    f.write('\tstp %s, %s, [x0, #%d]\n' % (B_REGS[i*2], B_REGS[i*2+1], offset))
  comment(f, "Carry into x11")
  f.write('\tadc x0, xzr, xzr\n')
  add_stack_and_restore_regs_from_stack(f, CALLE_SAVE_REGS, 0)
  f.write('\tret\n\n')

  ## _UINTBIG_SUB3 ______________________________________________________________________________________________
  comment(f, "Operation: A[x0] = B[x1] - C[x2] and x0 = borrow")
  introduce_global_function(f, globals['uintbig_sub3'])
  CALLE_SAVE_REGS = ['x19', 'x20']
  B_REGS = ['x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9', 'x10']
  C_REGS = ['x11', 'x12', 'x13', 'x14', 'x15', 'x16', 'x17', 'x19']
  sub_stack_and_store_on_stack(f, CALLE_SAVE_REGS, 0)
  for i in range(int(limbs/2)):
    offset = i*16
    f.write('\tldp %s, %s, [x1, #%d]\n' % (B_REGS[i*2], B_REGS[i*2+1], offset))
    f.write('\tldp %s, %s, [x2, #%d]\n' % (C_REGS[i*2], C_REGS[i*2+1], offset))
  f.write('\tsubs %s, %s, %s\n' % (B_REGS[0], B_REGS[0], C_REGS[0]))
  for i in range(1, limbs):
    f.write('\tsbcs %s, %s, %s\n' % (B_REGS[i], B_REGS[i], C_REGS[i]))
  for i in range(int(limbs/2)):
    offset = i*16
    f.write('\tstp %s, %s, [x0, #%d]\n' % (B_REGS[i*2], B_REGS[i*2+1], offset))
  comment(f, "Carry into x11")
  f.write('\tsbc x0, xzr, xzr\n')
  add_stack_and_restore_regs_from_stack(f, CALLE_SAVE_REGS, 0)
  f.write('\tret\n\n')
  



  ## _UINTBIG_MUL3_64 ______________________________________________________________________________________________
  comment(f, "Operation: A[x0] = B[x1] * C[x2] and C = direct value 64 bit not address")
  introduce_global_function(f, globals['uintbig_mul3_64'])
  for i in range(int(limbs/2)):
    offset = i*16 
    comment(f, str(i*2) + " Limb")
    f.write('\tldp x3, x4, [x1, #%d]\n' % (i*16))
    f.write('\tmul x5, x3, x2 // low mul\n')   
    if i == 0:
      f.write('\tumulh x6, x3, x2 // high mul\n')
      f.write('\tstr x5, [x0, #%d]\n\n' % (i*16))
      comment(f, str(i*2 + 1) + " Limb")
      f.write('\tmul x5, x4, x2 // low mul\n')
      f.write('\tadds x5, x5, x6 // add past higher mul\n')
      f.write('\tstr x5, [x0, #%d]\n' % (i*16+8))
      f.write('\tumulh x6, x4, x2 // high mul\n\n')
    if i > 0:
      f.write('\tadcs x5, x5, x6 // add past higher mul\n')
      f.write('\tstr x5, [x0, #%d]\n' % (i*16))
      f.write('\tumulh x6, x3, x2 // high mul\n') 
      comment(f, str(i*2 + 1) + " Limb")
      f.write('\tmul x5, x4, x2 // low mul\n')
      f.write('\tadcs x5, x5, x6 // add past higher mul\n')
      f.write('\tstr x5, [x0, #%d]\n' % (i*16+8)) 
      f.write('\tumulh x6, x4, x2 // high mul \n\n')
  f.write('\tret\n\n')


  ## _UINTBIG_MUL3_64_full ______________________________________________________________________________________________
  ## Results in 9 words
  comment(f, "Operation: A[x0] = B[x1] * C[x2] and C = direct value 64 bit not address\n results in 9 words")
  introduce_global_function(f, globals['uintbig_mul3_64_full'])
  for i in range(int(limbs/2)):
    offset = i*16 
    comment(f, str(i*2) + " Limb")
    f.write('\tldp x3, x4, [x1, #%d]\n' % (i*16))
    f.write('\tmul x5, x3, x2 // low mul\n')   
    if i == 0:
      f.write('\tumulh x6, x3, x2 // high mul\n')
      f.write('\tstr x5, [x0, #%d]\n\n' % (i*16))
      comment(f, str(i*2 + 1) + " Limb")
      f.write('\tmul x5, x4, x2 // low mul\n')
      f.write('\tadds x5, x5, x6 // add past higher mul\n')
      f.write('\tstr x5, [x0, #%d]\n' % (i*16+8))
      f.write('\tumulh x6, x4, x2 // high mul\n\n')
    if i > 0:
      f.write('\tadcs x5, x5, x6 // add past higher mul\n')
      f.write('\tstr x5, [x0, #%d]\n' % (i*16))
      f.write('\tumulh x6, x3, x2 // high mul\n') 
      comment(f, str(i*2 + 1) + " Limb")
      f.write('\tmul x5, x4, x2 // low mul\n')
      f.write('\tadcs x5, x5, x6 // add past higher mul\n')
      f.write('\tstr x5, [x0, #%d]\n' % (i*16+8)) 
      f.write('\tumulh x6, x4, x2 // high mul \n\n')
  f.write('\tadc x6, x6, xzr\n')
  f.write('\tstr x6, [x0, #%d]\n' % (8*8))
  f.write('\tret\n\n')
  maybeupdate(fn) 





