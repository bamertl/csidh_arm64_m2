#!/usr/bin/env python3

import os
import math
import re
import sys

limbs = 8

sys.setrecursionlimit(10000)

print("Generating fp512_arm.S this is fancy...")

def maybeupdate(fn):
  if os.access(fn,os.F_OK):
    with open(fn) as f:
      x = f.read()
    with open(fn+'.tmp') as f:
      y = f.read()
    if x == y:
      os.unlink(fn+'.tmp')
      return
  os.rename(fn+'.tmp',fn)

def comment(f, comment):
    f.write('/* %s */\n' % comment)

def init_data_var(f, name):
    f.write('.global %s\n' % name)
    f.write('%s: \n' % name)
    f.write('\t.quad 0\n')

def introduce_global_function(f, name):
    f.write('.global %s\n' % name)
    f.write('%s: \n' % name)

def sub_stack_and_store_on_stack(f, regs, additional_offset):
    total_offset = len(regs)*8 + additional_offset 
    if total_offset % 16 != 0:
        total_offset = ((total_offset // 16) + 1) * 16
    f.write('\tsub sp, sp, #%d\n' % total_offset)
    offset = 0
    i = 0
    while i < len(regs):
        # Check if there's at least one more register after the current one
        if i + 1 < len(regs):
            # If yes, store the pair of registers
            f.write('\tstp %s, %s, [sp, #%d]\n' % (regs[i], regs[i+1], offset))
            i += 2
        else:
            # If no, store the single register
            f.write('\tstr %s, [sp, #%d]\n' % (regs[i],offset))
            i += 1
        offset += 16

def add_stack_and_restore_regs_from_stack(f, regs, additional_offset):
    total_offset = len(regs)*8 + additional_offset 
    if total_offset % 16 != 0:
        total_offset = ((total_offset // 16) + 1) * 16
    offset = 0
    i = 0
    while i < len(regs):
        # Check if there's at least one more register after the current one
        if i + 1 < len(regs):
            # If yes, store the pair of registers
            f.write('\tldp %s, %s, [sp, #%d]\n' % (regs[i], regs[i+1], offset))
            i += 2
        else:
            # If no, store the single register
            f.write('\tldr %s, [sp, #%d]\n' % (regs[i],offset))
            i += 1
        offset += 16
    f.write('\tadd sp, sp, #%d\n' % total_offset)

fn = '../fp512_arm64.S'
with open(fn+'.tmp','w') as f:
    f.write('/* DO NOT EDIT! generated by autogen */\n\n')
    f.write('#include "uintbig_namespace.h"\n')
    f.write('#include "fp_namespace.h"\n')

    f.write('\n')
    f.write('.set pbits,511 \n')
    f.write('.set pbytes,64 \n')
    f.write('.set plimbs,8 \n')
    f.write('\n')

    f.write('_inv_min_p_mod_r: \n')
    f.write('\t.quad 0x66c1301f632e294d\n')
    f.write('\n')

    introduce_global_function(f, '_fp_0')
    f.write('\t.zero 64')
    f.write('\n')

    introduce_global_function(f, '_fp_1')
    f.write('\t.quad 0xc8fc8df598726f0a, 0x7b1bc81750a6af95, 0x5d319e67c1e961b4, 0xb0aa7275301955f1\n')
    f.write('\t.quad 0x4a080672d9ba6c64, 0x97a5ef8a246ee77b, 0x06ea9e5d4383676a, 0x3496e2e117e0ec80\n')
    f.write('\n')

    introduce_global_function(f, '_fp_2')
    f.write('\t.quad 0x767762e5fd1e1599, 0x33c5743a49a0b6f6, 0x68fc0c0364c77443, 0xb9aa1e24f83f56db\n')
    f.write('\t.quad 0x3914101f20520efb, 0x7b1ed6d95b1542b4, 0x114a8be928c8828a, 0x03793732bbb24f40\n')
    f.write('\n')

    f.write('_r_squared_mod_p:\n')
    f.write('\t.quad 0x36905b572ffc1724, 0x67086f4525f1f27d, 0x4faf3fbfd22370ca, 0x192ea214bcc584b1\n')
    f.write('\t.quad 0x5dae03ee2f5de3d0, 0x1e9248731776b371, 0xad5f166e20e4f52d, 0x4ed759aea6f3917e\n')
    f.write('\n')

    # Data section
    f.write('.data\n')
    init_data_var(f, '_fp_mulsq_count')
    init_data_var(f, '_fp_sqr_count')
    init_data_var(f, '_fp_addsub_count')
    f.write('\n')
    
    # Text section
    f.write('.text\n')
    f.write('.align 4\n')
    comment(f, "this means 16 byte alignment")
    f.write('\n')

    # _FP_COPY
    comment(f, "x1 = x0  x0 is being copied to x1(8 words)")
    introduce_global_function(f, '_fp_copy')
    for i in range(int(limbs/2)):
        memory_offset = i*16
        f.write('\tldp x2, x3, [x1, #%d]\n' % memory_offset)
        f.write('\tstp x2, x3, [x0, #%d]\n' % memory_offset)
    f.write("\tret\n") 
    f.write('\n')

    # _FP_CMOV
    comment(f, "A[x0] = B[x1] if d[x2], we make it time-constant")
    introduce_global_function(f, '_fp_cmov')
    comment(f, "Loop 4 times through the 8 words")
    comment(f, "(AxorB)^d xor A = A")
    for i in range(int(limbs/2)):
        memory_offset = i*16
        comment(f, "LOOP %d" % i)
        f.write('\tldp x3, x4, [x1, #%d]\n' % memory_offset)
        f.write('\tldp x5, x6, [x0, #%d]\n' % (memory_offset))
        f.write('\teor x3, x3, x5\n')
        f.write('\teor x4, x4, x6\n')
        f.write('\teor x3, x3, x2\n')
        f.write('\teor x4, x4, x2\n')
        f.write('\teor x3, x3, x5\n')
        f.write('\teor x4, x4, x6\n')
        f.write('\tstp x3, x4, [x0, #%d]\n' % (memory_offset))
    f.write("\tret\n") 
    f.write('\n')

    # _FP_CSWAP _____________________________________________________________________________________
    comment(f, "A[x0] <-> B[x1] if d[x2], we make it time-constant")
    introduce_global_function(f, '_fp_cswap')
    for i in range(int(limbs/2)):
        comment(f, "LOOP %d" % i)
        memory_offset = i*16
        f.write('\tldp x3, x4, [x0, #%d]\n' % memory_offset)
        f.write('\tldp x5, x6, [x1, #%d]\n' % (memory_offset))
        f.write('\teor x7, x3, x5\n')
        f.write('\teor x8, x4, x6\n')

        f.write('\teor x7, x7, x2\n')
        f.write('\teor x8, x8, x2\n')

        f.write('\teor x3, x7, x3\n')
        f.write('\teor x4, x8, x4\n')
        f.write('\teor x5, x7, x5\n')
        f.write('\teor x6, x8, x6\n')

        f.write('\tstp x3, x4, [x0, #%d]\n' % (memory_offset))
        f.write('\tstp x5, x6, [x1, #%d]\n' % (memory_offset))	
    f.write("\tret\n") 
    f.write('\n')
    #_FP_ADD2, just straight to _fp_add3 _____________________________________________________________________________________
    comment(f, "A[x0] = A[x0] + B[x1]")
    introduce_global_function(f, '_fp_add2')
    f.write('\mov x0, x2')
    #_FP_ADD3 _____________________________________________________________________________________
    introduce_global_function(f, '_fp_add3')
    comment(f, "A[x0] = A[x0] + B[x1] + C[x2]")
    comment(f, "LOAD A")
    REGS_TO_STORE = ["x19, x20, x21"]
    A_REGS = ['x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9','x10']
    B_REGS = ['x11', 'x12', 'x13', 'x14', 'x15', 'x16', 'x17','x19']
    P_REGS = ['x12', 'x13', 'x14', 'x15', 'x16', 'x17', 'x19', 'x20']

    sub_stack_and_store_on_stack(f, REGS_TO_STORE, 0)

    comment(f, "load A and B")
    for i in range(int(limbs/2)):
        f.write("\t ldp %s, %s, [x0, #%d]\n" % (A_REGS[i*2], A_REGS[i*2+1], i*16))
        f.write("\t ldp %s, %s, [x1, #%d]\n" % (B_REGS[i*2], B_REGS[i*2+1], i*16))
    comment(f, "A + B")    
    f.write("\t ADDS %s, %s, %s\n" % (A_REGS[0], A_REGS[0], B_REGS[0]))
    for i in range(1, limbs):
        f.write("\t ADCS %s, %s, %s\n" % (A_REGS[i], A_REGS[i], B_REGS[i]))
    #Carry into x11
    f.write("\t ADCS x11, xzr, xzr\n")
    comment(f, "LOAD P")
    for i in range(int(limbs/2)):
        f.write("\t ldp %s, %s, [x21, #%d]\n" % (P_REGS[i*2], P_REGS[i*2+1], i*16))
    comment(f, "A + B - P")
    f.write("\t SUBS %s, %s, %s\n" % (A_REGS[0], A_REGS[0], P_REGS[0]))
    for i in range(1, limbs):
        f.write("\t SBCS %s, %s, %s\n" % (A_REGS[i], A_REGS[i], P_REGS[i]))
    f.write("\tSBCS x11, x11, xzr\n")
    f.write("\tSBCS x21, xzr, xzr\n")
    comment(f, "Carry into x21") 

    comment(f, "MASK P with carry")
    for i in range(int(limbs)):
        f.write("\t AND %s, %s, x21\n" % (P_REGS[i], P_REGS[i]))
    
    comment(f, "A + B - P + P")
    f.write("\t ADDS %s, %s, %s\n" % (A_REGS[0], A_REGS[0], P_REGS[0]))
    for i in range(1, limbs):
        f.write("\tADCS %s, %s, %s\n" % (A_REGS[i], A_REGS[i], P_REGS[i]))
    comment(f, "STORE RESULT")
    for i in range(int(limbs/2)):
       memory_offest = i*16
       f.write("\tstp %s, %s, [x0, #%d]\n" % (A_REGS[i*2], A_REGS[i*2+1], memory_offest))

    add_stack_and_restore_regs_from_stack(f, REGS_TO_STORE, 0)
    f.write("\tret\n")
    f.write("\n")







    maybeupdate(fn)