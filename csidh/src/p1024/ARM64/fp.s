/* DO EDIT! generated by autogen */
.extern _r_squared_mod_p
.extern _p_minus_2
.extern _uint_1
.extern _p_minus_1_halves
.extern _p
.extern _fp_1
.extern _fp_mul3
.extern _uint_eq
.extern _uint_set
.extern _uint_add3
.extern _uint_sub3

.align 4
.data
.global _fp_sq_counter
_fp_sq_counter: .quad 0
.global _fp_mul_counter
_fp_mul_counter: .quad 0
.global _fp_inv_counter
_fp_inv_counter: .quad 0
.global _fp_sqt_counter
_fp_sqt_counter: .quad 0

.text
/*
 x0 = [x0] == [x1]  
*/
.global _fp_eq
_fp_eq: 
	b _uint_eq

/*
 [x0] = [x1,0,0,0,0] and encode to montgomery space  
*/
.global _fp_set
_fp_set: 
	sub sp, sp, #16
	str lr, [sp, #0]
	bl _uint_set
	mov x1, x0  // move result to x1 (input for fp_enc) 
	ldr lr, [sp, #0]
	add sp, sp, #16
	b _fp_enc

/*
 [x0] = [x1] * [r_squared_mod_p] mod [p]  
*/
.global _fp_enc
_fp_enc: 
	adrp x2, _r_squared_mod_p@PAGE
	add x2, x2, _r_squared_mod_p@PAGEOFF
	b _fp_mul3

/*
 [x0] = [x1] * [_uint_1] mod [p] = decoded [x1] out of montgomery space  
*/
.global _fp_dec
_fp_dec: 
	adrp x2, _uint_1@PAGE
	add x2, x2, _uint_1@PAGEOFF
	b _fp_mul3
/*
 [x0] = [x0] * [x1] mod [p]  
*/
.global _fp_mul2
_fp_mul2: 
	mov x2, x0  // move x0 to x2 
	b _fp_mul3

/*
 [x0] = [x0] + [x1] mod [p]  
*/
.global _fp_add2
_fp_add2: 
	mov x2, x0  // move x0 to x2 
	/* straight into fp_add3 */

/*
 [x0] = [x1] + [x2] mod [p]  
*/
.global _fp_add3
_fp_add3: 
	sub sp, sp, #16
	stp x0, lr, [sp, #0]
	bl // this returns the carry in x0 _uint_add3
	mov x1, x0  // move the carry of a + b to x1 
	ldp x0, lr, [sp, #0]
	add sp, sp, #16
	b _reduce_once

/*
 [x0] = [x0]x1 - [p] mod [p] 
 x1 = potential overflow  
*/
.global _reduce_once
_reduce_once: 
	adrp x15, _p@PAGE
	add x15, x15, _p@PAGEOFF
	/* Limbs 0 - 3 */
	ldp x3, x4, [x0, #0]  // load A 
	ldp x5, x6, [x0, #16]  // load A 
	ldp x7, x8, [x15, #0]  // load P 
	ldp x9, x10, [x15, #16]  // load P 
	subs x11, x3, x7  
	sbcs x12, x4, x8  
	sbcs x13, x5, x9  
	sbcs x14, x6, x10  
	stp x11, x12, [x0, #0]  // store result 
	stp x13, x14, [x0, #16]  // store result 
	/* Limbs 4 - 7 */
	ldp x3, x4, [x0, #32]  // load A 
	ldp x5, x6, [x0, #48]  // load A 
	ldp x7, x8, [x15, #32]  // load P 
	ldp x9, x10, [x15, #48]  // load P 
	sbcs x11, x3, x7  
	sbcs x12, x4, x8  
	sbcs x13, x5, x9  
	sbcs x14, x6, x10  
	stp x11, x12, [x0, #32]  // store result 
	stp x13, x14, [x0, #48]  // store result 
	/* Limbs 8 - 11 */
	ldp x3, x4, [x0, #64]  // load A 
	ldp x5, x6, [x0, #80]  // load A 
	ldp x7, x8, [x15, #64]  // load P 
	ldp x9, x10, [x15, #80]  // load P 
	sbcs x11, x3, x7  
	sbcs x12, x4, x8  
	sbcs x13, x5, x9  
	sbcs x14, x6, x10  
	stp x11, x12, [x0, #64]  // store result 
	stp x13, x14, [x0, #80]  // store result 
	/* Limbs 12 - 15 */
	ldp x3, x4, [x0, #96]  // load A 
	ldp x5, x6, [x0, #112]  // load A 
	ldp x7, x8, [x15, #96]  // load P 
	ldp x9, x10, [x15, #112]  // load P 
	sbcs x11, x3, x7  
	sbcs x12, x4, x8  
	sbcs x13, x5, x9  
	sbcs x14, x6, x10  
	stp x11, x12, [x0, #96]  // store result 
	stp x13, x14, [x0, #112]  // store result 
	/* Final carry of a+b-p */
	sbcs x1, x1, xzr  // potential overflow of a+b 
	sbcs x1, xzr, xzr  // if a-p negative, carry is 1 
	/* AND P and a + p */
	/* Limbs 0 - 3 */
	ldp x3, x4, [x0, #0]  // load A 
	ldp x5, x6, [x0, #16]  // load A 
	ldp x7, x8, [x15, #0]  // load P 
	ldp x9, x10, [x15, #16]  // load P 
	and x7, x7, x1  
	and x8, x8, x1  
	and x9, x9, x1  
	and x10, x10, x1  

	adcs x11, x3, x7  
	adcs x12, x4, x8  
	adcs x13, x5, x9  
	adcs x14, x6, x10  
	stp x11, x12, [x0, #0]  // store result 
	stp x13, x14, [x0, #16]  // store result 
	/* Limbs 4 - 7 */
	ldp x3, x4, [x0, #32]  // load A 
	ldp x5, x6, [x0, #48]  // load A 
	ldp x7, x8, [x15, #32]  // load P 
	ldp x9, x10, [x15, #48]  // load P 
	and x7, x7, x1  
	and x8, x8, x1  
	and x9, x9, x1  
	and x10, x10, x1  

	adcs x11, x3, x7  
	adcs x12, x4, x8  
	adcs x13, x5, x9  
	adcs x14, x6, x10  
	stp x11, x12, [x0, #32]  // store result 
	stp x13, x14, [x0, #48]  // store result 
	/* Limbs 8 - 11 */
	ldp x3, x4, [x0, #64]  // load A 
	ldp x5, x6, [x0, #80]  // load A 
	ldp x7, x8, [x15, #64]  // load P 
	ldp x9, x10, [x15, #80]  // load P 
	and x7, x7, x1  
	and x8, x8, x1  
	and x9, x9, x1  
	and x10, x10, x1  

	adcs x11, x3, x7  
	adcs x12, x4, x8  
	adcs x13, x5, x9  
	adcs x14, x6, x10  
	stp x11, x12, [x0, #64]  // store result 
	stp x13, x14, [x0, #80]  // store result 
	/* Limbs 12 - 15 */
	ldp x3, x4, [x0, #96]  // load A 
	ldp x5, x6, [x0, #112]  // load A 
	ldp x7, x8, [x15, #96]  // load P 
	ldp x9, x10, [x15, #112]  // load P 
	and x7, x7, x1  
	and x8, x8, x1  
	and x9, x9, x1  
	and x10, x10, x1  

	adcs x11, x3, x7  
	adcs x12, x4, x8  
	adcs x13, x5, x9  
	adcs x14, x6, x10  
	stp x11, x12, [x0, #96]  // store result 
	stp x13, x14, [x0, #112]  // store result 
	ret 


/*
 [x0] = [x0] - [x1] mod [p]  
*/
.global _fp_sub2
_fp_sub2: 
	mov x2, x1  // move x1 to x2 
	mov x1, x0  // move x0 to x1 
	/* straight into fp_sub3 */

/*
 [x0] = [x1] - [x2] mod [p] 
 saving temp of x2 in the stack might not be necessary but better safe then sorry  
*/
.global _fp_sub3
_fp_sub3: 
	/* we add -[x2] by first calculating [p] - [x2] */
	sub sp, sp, #160
	stp x0, x1, [sp, #0]
	str lr, [sp, #16]
	/* [temp] = [p] - [x2] */
	adds x0, sp, 24  
	adrp x1, _p@PAGE
	add x1, x1, _p@PAGEOFF
	bl _uint_sub3 
	ldr x0, [sp, #0]  // load initial result addr 
	ldr x1, [sp, #8]  // load initial x1 
	adds x2, sp, 24  
	bl _reduce_once
	ldp x0, x1, [sp, #0]
	ldr lr, [sp, #16]
	add sp, sp, #160
	retn


/*
 [x0] = [x0] * [x0] mod [p]  
*/
.global _fp_sq1
_fp_sq1: 
	/* straight into fp_sq2 */
	mov x1, x0  // move x0 to x1 

/*
 [x0] = [x1] * [x1] mod [p]  
*/
.global _fp_sq2
_fp_sq2: 
	/* First we set the mul counter pointer to 0, so it doesnt get updated, later we restore it */
	adrp x3, _fp_mul_counter@PAGE
	add x3, x3, _fp_mul_counter@PAGEOFF
	ldr x4, [x3, #0]  // load counter pointer 
	sub sp, sp, #32
	stp lr, x3, [sp, #0]
	str x4, [sp, #16]
	str xzr, [x3, #0]

	/* Now count up sq_counter */
	adrp x3, _fp_sq_counter@PAGE
	add x3, x3, _fp_sq_counter@PAGEOFF
	ldr x3, [x3, #0]  // load counter pointer 
	cbz x3, 0f // skip to 0f if pointer to mul_counter is 0 
	ldr x4, [x3, #0]  // load counter value 
	adds x4, x4, #1  // increase counter value 
	str x4, [x3, #0]

	0: // skip label
	mov x2, x1  // move x1 to x2 for mul 
	bl _fp_mul3
	ldp lr, x3, [sp, #0]
	ldr x4, [sp, #16]
	add sp, sp, #32
	str x4, [x3, #0]
	ret


